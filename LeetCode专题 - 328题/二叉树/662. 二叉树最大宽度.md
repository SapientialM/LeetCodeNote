# [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

## 基本思想
**给每个节点分配一个位置编号**，就像给数组元素编号一样，这样就能直接计算宽度。

## 编号规则
- **根节点**：位置 = 0
- **左子节点**：位置 = 父节点位置 × 2
- **右子节点**：位置 = 父节点位置 × 2 + 1

## 举例说明
```
      0(0)
     /     \
  1(0)     2(1)
  /  \     /  \
3(0) 4(1) 5(2) 6(3)
```

## 计算宽度
对于每一层：
- **最左节点位置** = 队列第一个节点的位置
- **最右节点位置** = 队列最后一个节点的位置  
- **宽度** = 最右位置 - 最左位置 + 1

### 示例计算：
```
第0层：只有节点0，位置0
宽度 = 0 - 0 + 1 = 1

第1层：节点1(位置1)，节点2(位置2)  
最左位置 = 0，最右位置 = 1
宽度 = 1 - 0 + 1 = 2
```

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        
        Deque<Pair<TreeNode, Integer>> queue = new ArrayDeque<>();
        queue.offer(new Pair<>(root, 0));
        int maxWidth = 0;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            int left = queue.peek().getValue(); // 当前层最左节点的位置
            int right = left;
            
            for (int i = 0; i < size; i++) {
                Pair<TreeNode, Integer> pair = queue.poll();
                TreeNode node = pair.getKey();
                right = pair.getValue(); // 当前层最右节点的位置
                
                if (node.left != null) {
                    queue.offer(new Pair<>(node.left, 2 * right));
                }
                if (node.right != null) {
                    queue.offer(new Pair<>(node.right, 2 * right + 1));
                }
            }
            
            maxWidth = Math.max(maxWidth, right - left + 1);
        }
        
        return maxWidth;
    }
}

```

