# [556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)

其实可以用单调栈。

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int res[] = new int[nums.length];
        int ri = 0;
        for(int i = 0; i < nums.length; i ++){
            int n = 1;
            int d = i + 1;
            boolean isFind = false;
            while(n < nums.length){
                if(d == nums.length){
                    d = 0;
                }
                if(nums[d] > nums[i]){
                    res[ri++] = nums[d];
                    isFind = true;
                    break;
                }
                d ++;
                n ++;
            }
            if(!isFind){
                res[ri++] = -1;
            }
        }
        return res;
    }
}
```

使用单调栈解决循环数组中"下一个更大元素"问题的思路如下：

## 核心思路

**单调递减栈**：维护一个栈，存储数组元素的**索引**（而不是值），保持栈中索引对应的元素值是**单调递减**的。

## 具体步骤

1. **初始化**：
   - 创建结果数组 `res`，初始值全部设为 -1（表示默认没有下一个更大元素）
   - 创建空栈 `stack` 用于存储索引

2. **遍历扩展数组**：
   - 由于是循环数组，通常遍历 **2倍数组长度**（即 `2 * n`）
   - 使用取模运算 `i % n` 来模拟循环访问

3. **处理每个元素**：
   - 对于当前索引 `i % n` 对应的元素 `nums[i % n]`：
     - **当栈不为空且当前元素大于栈顶索引对应的元素时**：
       - 弹出栈顶索引 `index`
       - 设置 `res[index] = nums[i % n]`（找到下一个更大元素）
     - **将当前索引入栈**（注意：实际入栈的是 `i % n`）

4. **优化**：
   - 可以只遍历到 `2n-1`，因为最多只需要循环一圈
   - 栈中存储索引而不是值，便于在结果数组中定位

## 为什么这样有效？

- **单调递减栈**保证了栈中元素是递减的，当遇到更大的元素时，就可以为栈中多个元素找到下一个更大值
- **循环遍历2倍长度**确保了每个元素都有机会找到其下一个更大值（即使需要绕到数组开头）
- **取模运算**模拟了数组的循环特性

## 时间复杂度：O(n)
每个元素最多入栈和出栈各一次，虽然是2n次遍历，但总体仍是线性时间复杂度。

这种解法巧妙地利用了单调栈的特性和循环数组的取模访问，高效地解决了问题。