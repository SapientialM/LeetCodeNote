# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```java
import java.util.Stack;

class Solution {
    public int trap(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        
        Stack<Integer> st = new Stack<>();
        int sumArea = 0;
        
        for (int i = 0; i < height.length; i++) {
            while (!st.empty() && height[i] > height[st.peek()]) {
                int bottomIndex = st.pop();
                if (st.empty()) {
                    break;
                }
                int leftIndex = st.peek();
                int distance = i - leftIndex - 1;
                int boundedHeight = Math.min(height[i], height[leftIndex]) - height[bottomIndex];
                sumArea += distance * boundedHeight;
            }
            st.push(i);
        }
        
        return sumArea;
    }
}
```

1. **使用单调递减栈**：栈中存储的是索引，保持栈中对应的高度是递减的

2. **计算逻辑**：
   - 当当前高度大于栈顶高度时，弹出栈顶作为底部
   - 如果栈不为空，计算左边界的索引
   - 计算宽度：`i - leftIndex - 1`
   - 计算高度：左右边界的最小高度减去底部高度
   - 累加面积：宽度 × 高度

3. **边界条件处理**：
   - 处理空数组的情况
   - 当弹出底部后栈为空时，说明没有左边界，无法形成凹槽

4. **时间复杂度**：O(n)，每个元素最多入栈和出栈一次
5. **空间复杂度**：O(n)，最坏情况下所有元素都在栈中

考虑多个测试用例，包括：
- 空数组
- 单调递增/递减的数组
- 有多个凹槽的情况
- 相同高度的情况