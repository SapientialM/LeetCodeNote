# [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

二维DP用于解决更加复杂的子序列问题

遇到问题，用DP分析：

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();
        // dp[i][j]表示前i-1位的s序列中出现前j-1的t序列的次数
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化：dp[i][0] = 1
        // 解释：空字符串t是任何字符串s的子序列，且只有1种方式（删除所有字符）
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 1;
        }
        // dp[0][j] = 0 (j > 0) 默认就是0，不需要显式初始化
        // 解释：非空字符串t不可能是空字符串s的子序列
        
        for (int i = 1; i <= m; i++) {           // 遍历s的每个字符
            for (int j = 1; j <= n; j++) {       // 遍历t的每个字符
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // 情况1：当前字符匹配
                    // 有两种选择：
                    // 选择1：使用s[i-1]匹配t[j-1] -> 看s[0...i-2]匹配t[0...j-2]的方案数：dp[i-1][j-1]
                    // 选择2：不使用s[i-1]匹配t[j-1] -> 看s[0...i-2]匹配t[0...j-1]的方案数：dp[i-1][j]
                    // 总方案数 = 两种选择之和
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    // 情况2：当前字符不匹配
                    // 只能跳过s的当前字符，看s[0...i-2]匹配t[0...j-1]的方案数
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        return dp[m][n];
    }
}

```

状态压缩：
```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();
        int[] dp = new int[n + 1];  // dp[j] 表示当前行匹配t的前j个字符的方案数
        
        dp[0] = 1;  // 空字符串t是任何字符串的子序列
        
        for (int i = 1; i <= m; i++) {
            int prev = dp[0];  // 保存dp[i-1][j-1]，初始为dp[i-1][0] = 1
            for (int j = 1; j <= n; j++) {
                int temp = dp[j];  // 保存dp[i-1][j]，即上一行的值
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // 当前字符匹配：dp[j] = dp[i-1][j-1] + dp[i-1][j]
                    // prev = dp[i-1][j-1], temp = dp[i-1][j]
                    dp[j] = prev + temp;
                } else {
                    // 当前字符不匹配：dp[j] = dp[i-1][j] = temp
                    dp[j] = temp;
                }
                prev = temp;  // 更新prev为当前j位置的上一行值，供下一轮j+1使用
            }
        }
        
        return dp[n];
    }
}

```

