# [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

### 1. **状态定义**

`dp[i][j]` = 字符串 `s[i...j]` 的最长回文子序列长度

### 2. **填表顺序**

- 外层循环：`i` 从 `n-1` 到 `0`（从下往上）
- 内层循环：`j` 从 `i` 到 `n-1`（从左到右）

这样保证在计算 `dp[i][j]` 时，`dp[i+1][j-1]`、`dp[i+1][j]`、`dp[i][j-1]` 都已经计算过了。

### 3. **状态转移方程**

#### 情况1：`s[i] == s[j]`

- **基础情况** (`j-i < 2`)：
  - `i == j`：单个字符，长度 = 1
  - `j == i+1`：两个相同字符，长度 = 2
- **一般情况**：`dp[i][j] = dp[i+1][j-1] + 2`
  - 因为两端的字符相同，可以同时加入回文子序列

#### 情况2：`s[i] != s[j]`

- `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`
  - 去掉左端字符，看 `s[i+1...j]`
  - 去掉右端字符，看 `s[i...j-1]`
  - 取两者的最大值

### 4. **最终结果**

`dp[0][n-1]` 就是整个字符串的最长回文子序列长度

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // i ~ j 最长回文子序列的长度
        int dp[][] = new int[n][n];
        for(int i = n-1; i >= 0; i --){
            for(int j = i; j < n; j ++){
                if(s.charAt(i) == s.charAt(j)){
                    if(j - i < 2) dp[i][j] = j - i + 1;
                    else dp[i][j] = dp[i+1][j-1] + 2; // 这里是 + 2，因为多两个字符
                }
                else{
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
}
```

