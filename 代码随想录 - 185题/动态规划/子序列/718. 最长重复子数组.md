# [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

> 注意，题目没说，但是实际上是要求连续子数组

nums1 塞到 nums2 里去，如果塞到一个同序，就 dp[j] = d[j-1] + 1

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        // 实际上这是最长公共子串问题的动态规划解法
        // 使用一维dp数组进行空间优化
        
        int n = nums1.length;
        // dp[j] 表示：以nums1[j-1]和当前nums2[i-1]结尾的最长公共子数组长度
        int dp[] = new int[n+1];
        dp[0] = 0; // 边界条件，空数组的公共子数组长度为0
        int result = 0; // 记录全局最大值
        
        // 外层循环遍历nums2（相当于背包的格子）
        for(int i = 1; i <= nums2.length; i++){
            // 内层循环倒序遍历nums1（防止覆盖上一轮的结果）
            for(int j = n; j > 0; j--){
                if(nums1[j-1] == nums2[i-1]){
                    // 当前元素相等，公共子数组长度+1
                    dp[j] = dp[j-1] + 1;
                } else {
                    // 当前元素不等，公共子数组长度重置为0
                    dp[j] = 0;
                }
                // 更新全局最大值
                if(result < dp[j]) result = dp[j];
            }
        }
        return result;
    }
}
```

**关键点说明：**
- **dp[j]含义**：以`nums1[j-1]`和当前`nums2[i-1]`结尾的最长公共子数组长度
- **倒序遍历**：防止覆盖上一轮计算的结果，保证`dp[j-1]`是上一轮的值
- **状态转移**：当前元素相等时延续之前的公共子数组，不等时重置为0
- **空间优化**：将二维DP优化为一维，空间复杂度从O(mn)降到O(n)

这个解法的时间复杂度是O(mn)，空间复杂度是O(n)，其中m和n分别是两个数组的长度。