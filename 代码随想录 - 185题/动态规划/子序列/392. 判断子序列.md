# [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

二维基础dp

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // dp[i][j] 表示s的前i个字符是否是t的前j个字符的子序列
        int m = s.length(), n = t.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        
        // 初始化：空字符串是任何字符串的子序列
        for (int j = 0; j <= n; j++) {
            dp[0][j] = true;
        }
        // 其实很好理解，对于dp[i][n] 是否等于true，就等于说s.chatAt(i-1)是否有序存在
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    // 当前字符匹配，看前面的子序列是否成立
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 当前字符不匹配，尝试跳过t的当前字符
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        
        return dp[m][n];
    }
}

```

状态压缩

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length(), n = t.length();
        boolean[] dp = new boolean[m + 1];
        
        // 初始化：空字符串是子序列
        dp[0] = true;
        
        for (int j = 1; j <= n; j++) {
            // 从后往前遍历，避免覆盖
            boolean prev = dp[0]; // 保存dp[i-1][j-1]
            for (int i = 1; i <= m; i++) {
                boolean temp = dp[i]; // 保存当前状态
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i] = prev; // 等于dp[i-1][j-1]
                } else {
                    dp[i] = dp[i]; // 等于dp[i][j-1]，保持不变
                }
                prev = temp; // 更新prev
            }
        }
        
        return dp[m];
    }
}

```

还可以剪枝，当然，其实双指针最简单。

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0;
        for (int j = 0; j < t.length() && i < s.length(); j++) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
        }
        return i == s.length();
    }
}
```

