## 概念与入门

### 1. 什么是0-1背包问题？（一句话概括）

**你有一个固定容量的背包，面前有一堆物品，每件物品都有自己的重量和价值。你的目标是：在背包能装得下的前提下，选择一些物品装进去，使得背包里所有物品的总价值最大。**

这里的“0-1”是关键，意思是：**对于每件物品，你只有两种选择——要么整个放进去（1），要么整个放弃（0）。** 你不能只放一半（比如半台笔记本电脑），也不能放多次（比如放两个一模一样的手机）。

---

### 2. 一个生动的例子

想象一下，你准备去野营，你的背包最多能装 **6公斤** 的东西。

现在你有以下几件物品可以选择：

| 物品 | 重量 (kg) | 价值 (元) |
| :--- | :-------: | :-------: |
| 水   |     3     |    10     |
| 书   |     2     |     5     |
| 食物 |     4     |    12     |
| 外套 |     1     |     2     |
| 相机 |     2     |     8     |

**你的任务：** 从这5件物品中挑选一些，装进你的6公斤背包，让总价值最高。

---

### 3. 我们来试试几种选择（像做选择题一样）

- **方案A：装水和食物**
  - 总重量：3kg + 4kg = 7kg ❌（超重了！不行）
- **方案B：装书、食物和外套**
  - 总重量：2kg + 4kg + 1kg = 7kg ❌（又超重了！）
- **方案C：装水、书和外套**
  - 总重量：3kg + 2kg + 1kg = 6kg ✅（完美！）
  - 总价值：10 + 5 + 2 = **17元**
- **方案D：装食物和相机**
  - 总重量：4kg + 2kg = 6kg ✅（完美！）
  - 总价值：12 + 8 = **20元**

**比较一下：** 方案D（20元）比方案C（17元）的价值更高！那么20元就是最好的选择吗？我们还能不能找到更好的？

- **方案E：装水、相机和外套**
  - 总重量：3kg + 2kg + 1kg = 6kg ✅
  - 总价值：10 + 8 + 2 = **20元**（和方案D一样好）

在这个例子中，**20元** 就是我们能得到的最大价值。方案D和方案E都是最优解。

---

### 4. 核心思想与难点

你可能会想：“这还不简单？我把所有组合都试一遍不就行了？”

**没错！** 对于物品很少的情况，我们确实可以像上面那样“暴力枚举”，把所有可能的组合都算一遍。

**但是，难点在于：**
当物品数量（n）变大时，可能的组合数量会呈 **指数级** 增长。比如有100件物品，组合数就是 2¹⁰⁰，这是一个天文数字，即使用世界上最快的计算机，也算到宇宙毁灭也算不完。

**所以，我们需要一个“聪明”的算法，不用遍历所有情况，就能找到最优解。**

---

### 5. 解决方案：动态规划（DP）

这是解决0-1背包问题最经典的方法。别被这个名字吓到，它的核心思想非常直观：

**我们不再一次性考虑所有物品，而是一个一个地考虑，并且记录下在“不同背包容量”下，考虑“前几个物品”时，我们能获得的最大价值。**

我们可以把它想象成填一个表格：

- **行：** 代表我们逐个考虑的物品。（考虑第1个物品...考虑前i个物品...考虑所有n个物品）
- **列：** 代表背包的容量，从0到最大容量（比如0kg, 1kg, 2kg, ... 6kg）。

我们一步步填充这个表格，每一个格子的值都基于之前已经算好的结果，这样就避免了重复计算。

**核心决策逻辑（对于表格中的每一个格子）：**
当我们考虑前i件物品时，面对一个容量为j的背包，我们只有两种选择：

1.  **不装物品i：** 那么最大价值就等于“在同样容量j下，只考虑前i-1件物品”时的最大价值。
2.  **装物品i：** 那么背包必须先给物品i腾出空间。此时的最大价值等于 “物品i的价值” + “在容量 `j - 物品i的重量` 下，只考虑前i-1件物品”时的最大价值。

**我们只需要比较这两种选择，哪个价值大，就选哪个。**
`dp[i][j] = max(不选i的价值， 选i的价值)`

通过这种方式，我们最终填到表格右下角的那个值，就是我们的答案——在最大容量下，考虑所有物品能获得的最大价值。



好的！前面我们已经理解了标准的动态规划解法，现在我来给你讲解更高级、更节省空间的优化方法——**滚动数组**。

---

### 6. 优化方案：滚动数组（Rolling Array）

#### 为什么要优化？
在标准的DP解法中，我们使用了一个二维数组 `dp[i][j]`。如果物品有100个，背包容量是1000，我们就需要一个 `[101][1001]` 的数组。这在大多数情况下没问题，但如果问题规模非常大（比如物品10万，容量100万），这个二维数组就会占用巨大内存，可能导致内存不足。

**滚动数组的核心思想：** 我们发现，在计算 `dp[i][j]` 时，**只需要上一行的数据**（即 `dp[i-1][...]`），完全不需要更早的行（如 `dp[i-2][...]`, `dp[i-3][...]` 等）。既然如此，我们为什么还要保留整个二维数组呢？

---

#### 如何实现滚动数组？

我们只需要一个**一维数组** `dp[j]`，它表示：**在当前考虑的物品范围内，容量为j的背包能装下的最大价值。**

让我们用之前的例子来演示：
背包容量：6kg
物品：水(3kg,10元), 书(2kg,5元), 食物(4kg,12元), 外套(1kg,2元), 相机(2kg,8元)

**步骤1：初始化**
我们创建一个长度为7（容量0~6）的一维数组，初始值全为0：
`dp = [0, 0, 0, 0, 0, 0, 0]`

**步骤2：处理第一个物品（水，3kg，10元）**
我们从右往左更新数组（**这点很重要！**）：
- 对于容量j ≥ 3kg的情况，我们可以选择装水
- `dp[3] = max(dp[3], 10 + dp[0]) = max(0, 10+0) = 10`
- `dp[4] = max(dp[4], 10 + dp[1]) = max(0, 10+0) = 10`
- `dp[5] = max(dp[5], 10 + dp[2]) = max(0, 10+0) = 10`
- `dp[6] = max(dp[6], 10 + dp[3]) = max(0, 10+0) = 10`

更新后：`dp = [0, 0, 0, 10, 10, 10, 10]`

**步骤3：处理第二个物品（书，2kg，5元）**
继续从右往左更新：
- `dp[6] = max(10, 5 + dp[4]) = max(10, 5+10) = 15`
- `dp[5] = max(10, 5 + dp[3]) = max(10, 5+10) = 15`
- `dp[4] = max(10, 5 + dp[2]) = max(10, 5+0) = 10`
- `dp[3] = max(10, 5 + dp[1]) = max(10, 5+0) = 10`
- `dp[2] = max(0, 5 + dp[0]) = max(0, 5+0) = 5`

更新后：`dp = [0, 0, 5, 10, 10, 15, 15]`

**步骤4：处理第三个物品（食物，4kg，12元）**
从右往左更新：
- `dp[6] = max(15, 12 + dp[2]) = max(15, 12+5) = 17`
- `dp[5] = max(15, 12 + dp[1]) = max(15, 12+0) = 15`
- `dp[4] = max(10, 12 + dp[0]) = max(10, 12+0) = 12`

更新后：`dp = [0, 0, 5, 10, 12, 15, 17]`

**步骤5：处理第四个物品（外套，1kg，2元）**
从右往左更新：
- `dp[6] = max(17, 2 + dp[5]) = max(17, 2+15) = 17`
- `dp[5] = max(15, 2 + dp[4]) = max(15, 2+12) = 15`
- `dp[4] = max(12, 2 + dp[3]) = max(12, 2+10) = 12`
- `dp[3] = max(10, 2 + dp[2]) = max(10, 2+5) = 7`
- `dp[2] = max(5, 2 + dp[1]) = max(5, 2+0) = 5`
- `dp[1] = max(0, 2 + dp[0]) = max(0, 2+0) = 2`

更新后：`dp = [0, 2, 5, 10, 12, 15, 17]`

**步骤6：处理第五个物品（相机，2kg，8元）**
从右往左更新：
- `dp[6] = max(17, 8 + dp[4]) = max(17, 8+12) = 20`
- `dp[5] = max(15, 8 + dp[3]) = max(15, 8+10) = 18`
- `dp[4] = max(12, 8 + dp[2]) = max(12, 8+5) = 13`
- `dp[3] = max(10, 8 + dp[1]) = max(10, 8+2) = 10`
- `dp[2] = max(5, 8 + dp[0]) = max(5, 8+0) = 8`

最终：`dp = [0, 2, 8, 10, 13, 18, 20]`

**最终结果：** `dp[6] = 20`，与之前的结果一致！

---

### 为什么必须从右往左遍历？

> 因为我们使用的是上一层的dp数组，如果从左向右，就会覆盖掉上一次的。

这是滚动数组最精妙的地方！如果我们从左往右遍历：

处理相机(2kg,8元)时：
- `dp[2] = max(5, 8+0) = 8` ✓
- `dp[3] = max(10, 8 + dp[1]) = max(10, 8+2) = 10` ✓  
- `dp[4] = max(12, 8 + dp[2]) = max(12, 8+8) = 16` ❌（错误！）

这里 `dp[2]` 已经被更新为8（表示装了相机），然后计算 `dp[4]` 时又用到了这个新的 `dp[2]`，相当于**把同一个相机装了两次**！这违反了"0-1"原则。

**从右往左遍历**保证了在计算 `dp[j]` 时，用到的 `dp[j - weight]` 是**上一轮**的值，不会受到本轮更新的影响。

---

### 滚动数组总结

**优点：**
- 空间复杂度从 O(n×W) 降为 O(W)，大大节省内存
- 代码更简洁

**缺点：**
- 丢失了具体方案信息（只能知道最大价值，不知道具体选了哪些物品）
- 遍历顺序必须从右向左

**核心代码（非常简洁）：**
```python
def knapsack(weights, values, capacity):
    dp = [0] * (capacity + 1)
    for i in range(len(weights)):
        for j in range(capacity, weights[i] - 1, -1):  # 从右往左遍历
            dp[j] = max(dp[j], values[i] + dp[j - weights[i]])
    return dp[capacity]
```

这就是滚动数组的妙处——用一维数组"滚动"更新，既保持了正确性，又极大优化了空间！