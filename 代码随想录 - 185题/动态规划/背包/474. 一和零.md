# [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

二维费用的0-1背包问题。

## 🎯 问题理解

**题目要求：** 在字符串数组中找出最大的子集，使得子集中：
- '0'的总数 ≤ m
- '1'的总数 ≤ n

**本质：** 二维费用的0-1背包问题

## 🔍 问题分析

### 输入示例：
```
strs = ["10", "0", "1"], m = 1, n = 1
```

### 每个字符串的"重量"：
- `"10"` → (1个'0', 1个'1')
- `"0"` → (1个'0', 0个'1')  
- `"1"` → (0个'0', 1个'1')

## 💡 动态规划解法

### 状态定义
`dp[i][j]`：使用i个'0'和j个'1'能获得的最大子集大小

### 状态转移方程
对于每个字符串 `str`：
```java
for(int i = m; i >= zeros; i--) {
    for(int j = n; j >= ones; j--) {
        dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
    }
}
```

**解释：**
- `dp[i][j]`：不选当前字符串
- `dp[i - zeros][j - ones] + 1`：选当前字符串

## 🛠️ 完整代码实现

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // dp[i][j]：使用i个0和j个1能获得的最大子集大小
        int[][] dp = new int[m + 1][n + 1];
        
        for(String str : strs) {
            // 统计当前字符串的0和1数量
            int zeros = 0, ones = 0;
            for(char c : str.toCharArray()) {
                if(c == '0') zeros++;
                else ones++;
            }
            
            // 二维背包，从后往前遍历
            for(int i = m; i >= zeros; i--) {
                for(int j = n; j >= ones; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        
        return dp[m][n];
    }
}
```

## 🧪 手动模拟示例

**初始状态：**
```
dp = [
    [0, 0],
    [0, 0]
]
```

**处理 "10" (1个0, 1个1)：**
```
更新 dp[1][1] = max(0, dp[0][0] + 1) = 1
```

**处理 "0" (1个0, 0个1)：**
```
更新 dp[1][0] = max(0, dp[0][0] + 1) = 1
更新 dp[1][1] = max(1, dp[0][1] + 1) = max(1, 0+1) = 1
```

**处理 "1" (0个0, 1个1)：**
```
更新 dp[0][1] = max(0, dp[0][0] + 1) = 1
更新 dp[1][1] = max(1, dp[1][0] + 1) = max(1, 1+1) = 2
```

**最终结果：** `dp[1][1] = 2` ✅

## 📝 关键要点

1. **二维费用**：同时考虑'0'和'1'两种资源的限制
2. **0-1背包**：每个字符串只能选一次
3. **遍历顺序**：从后往前避免重复选择
4. **状态转移**：比较"选"与"不选"的优劣
