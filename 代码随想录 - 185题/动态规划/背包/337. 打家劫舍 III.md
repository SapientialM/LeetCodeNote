# [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

记忆化递归，后序遍历

```java
class Solution {
    // 初始化一个 nodeMap，记忆化递归
    private HashMap<TreeNode, Integer> nodeMap = new HashMap<>();
    public int rob(TreeNode root) {
        // 添加了二叉树作为背包存放节点
        // 首先考察的是遍历方式，后序遍历是最好的，即：考虑左子树、考虑右子树、考虑中
        // 因为每个树节点都是考虑取当前与不取当前来算最大价值
        if(root == null) return 0;
        if(root.left == null && root.right == null) return root.val;
        if(nodeMap.containsKey(root)) return nodeMap.get(root);
        int valRoot = root.val;
        if(root.left != null) valRoot += rob(root.left.left) + rob(root.left.right);
        if(root.right != null) valRoot += rob(root.right.left) + rob(root.right.right);
        int valChild = rob(root.left) + rob(root.right);
        int val = Math.max(valRoot, valChild);
        nodeMap.put(root, val);
        return val;

    }
}
```

动态规划，树形dp入门，关键在于一个偷与不偷当前节点，用二维数组记录，0 表示偷，1表示不偷

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = robAction(root);
        return Math.max(res[0], res[1]);
    }

    int[] robAction(TreeNode root) {
        int res[] = new int[2];
        if (root == null)
            return res;

        int[] left = robAction(root.left);
        int[] right = robAction(root.right);
		// 是从最底层开始计算的
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        res[1] = root.val + left[0] + right[0];
        return res;
    }
}
```

![img](https://file1.kamacoder.com/i/algo/20230203110031.png)