# [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

从0-1背包的想法，过渡到使用滚动数组，然后每次取最大价值

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i : nums){
            sum += i;
        }
        if(sum % 2 != 0) return false;
        int target = sum/2;
        // 是否能恰好装满背包
        int dp[] = new int[target + 1];
        // dp[target] = num => 想装target，但我只能装到 num
        for(int num : nums){
            // 对于每个数字，我们都试试当前数字是否能装出来
            // 从右往左，防止重复使用数据，这是滚动数组
            for(int i = target; i >= num; i --){
                // 取与不取，找最大价值
                // 数组默认是0，第一次遍历就会把dp[num] = num
                // 然后dp[target] 默认是0，所以每次都会尝试取每个数字
                dp[i] = Math.max(dp[i], dp[i-num] + num);
            }
        }
        return dp[target] == target;
    }   
}
```

### 为什么会 dp[target] == target 而不会出现 dp[target] > target？

其实你会发现，每次维护 dp[target] 时，实际上都是 dp[target] = max(d[target], dp[target - num] + num)，实际上就是每次在考虑是否取num，也就是给 dp[target] 加 num，而考虑的关键在于 dp[target - num]，那就是说，我 target - num 能拿到多少，但是你会发现 对于 dp[num] <= num 是一定存在的。

**举个例子：**

假设 `nums = [3, 3, 3, 3]`，总和 = 12，`target = 6`

**初始化：** `dp = [0, 0, 0, 0, 0, 0, 0]`（长度为7）

**处理过程：**

**第1个数字3：（我只装前 1 个元素，然后只从能装的容量来计算，不同容量最多能装多少东西）**

- `j=6`: `dp[6] = max(dp[6], dp[3] + 3) = max(0, 0+3) = 3`（容量6 看看装 3 价值更大，还是不装 3 原本的 dp[6] 价值更大）
- `j=5`: `dp[5] = max(dp[5], dp[2] + 3) = max(0, 0+3) = 3`
- `j=4`: `dp[4] = max(dp[4], dp[1] + 3) = max(0, 0+3) = 3`
- `j=3`: `dp[3] = max(dp[3], dp[0] + 3) = max(0, 0+3) = 3`

此时：`dp = [0, 0, 0, 3, 3, 3, 3]`

**第2个数字3：**

- `j=6`: `dp[6] = max(dp[6], dp[3] + 3) = max(3, 3+3) = 6` （从这个时候开始，我们就知道不可能有 dp[3] + num 会更大了，因为我们容量就是 6，你装满了）
- `j=5`: `dp[5] = max(dp[5], dp[2] + 3) = max(3, 0+3) = 3`
- `j=4`: `dp[4] = max(dp[4], dp[1] + 3) = max(3, 0+3) = 3`
- `j=3`: `dp[3] = max(dp[3], dp[0] + 3) = max(3, 0+3) = 3`

此时：`dp = [0, 0, 0, 3, 3, 3, 6]`