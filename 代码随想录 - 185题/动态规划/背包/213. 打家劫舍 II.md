# [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

相比于第一部，多了一个环，但是实际上就是1 和 n不能同时考虑的问题，于是就切分为两个序列进行计算，取最大值。当然，这个方法肯定会重复计算，只是便于理解。

```java
class Solution {
    public int rob(int[] nums) {
        // 相比于第一部，多了一个环形房屋
        // 1 和 n 是不可能同时存在的
        // 所以切分为  与 2 ~ n
        if(nums.length < 2) return nums[0];
        int dp1[] = new int[nums.length];
        int dp2[] = new int[nums.length];
        dp1[0] = 0;
        dp2[0] = 0;
        dp1[1] = nums[0];
        dp2[1] = nums[1];
        // 1~n-1
        for(int i = 1; i < nums.length - 1; i ++){
            // 从 1 开始的，会错位，所以 +1
            for(int j = i + 1; j < nums.length; j ++){
                dp1[j] = Math.max(dp1[j-1], dp1[j-2] + nums[i]);
            }
        }
        // 2~n
        for(int i = 2; i < nums.length; i ++){
            // 从2开始的，所以不会错位
            for(int j = i; j < nums.length; j ++){
                dp2[j] = Math.max(dp2[j-1], dp2[j-2] + nums[i]);
            }
        }
        return Math.max(dp1[nums.length - 1], dp2[nums.length - 1]);
    }
}
```

去重思路：其实后面的计算无意义，因为只考虑到第i个物品，不需要双循环

```java
class Solution {
    public int rob(int[] nums) {
        // 相比于第一部，多了一个环形房屋
        // 1 和 n 是不可能同时存在的
        // 所以切分为  与 2 ~ n
        if(nums.length < 2) return nums[0];
        int dp1[] = new int[nums.length];
        int dp2[] = new int[nums.length];
        dp1[0] = 0;
        dp2[0] = 0;
        dp1[1] = nums[0];
        dp2[1] = nums[1];
        // 1~n-1
        for(int i = 1; i < nums.length - 1; i ++){
            // 从1开始会错位
            dp1[i+1] = Math.max(dp1[i], dp1[i-1] + nums[i]);
            
        }
        // 2~n
        for(int i = 2; i < nums.length; i ++){
            // 从2开始的，所以不会错位
            dp2[i] = Math.max(dp2[i-1], dp2[i-2] + nums[i]);
        }
        return Math.max(dp1[nums.length - 1], dp2[nums.length - 1]);
    }
}
```

