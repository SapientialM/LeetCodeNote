# [46. 全排列](https://leetcode.cn/problems/permutations/)

HashSet + 切割回溯

```java
class Solution {
    List<Integer> path; 
    List<List<Integer>> res;
    public List<List<Integer>> permute(int[] nums) {
        // 全排列，则固定长度，包括顺序，其实就是一个N叉树
        path = new ArrayList<>();
        res = new ArrayList<>();
        HashSet<Integer> sets = new HashSet<>();
        for(int i : nums){
            sets.add(i);
        }
        backtracking(sets);
        return res;
    }
    private void backtracking(HashSet<Integer> sets){
        if(sets.size() == 0){
            res.add(new ArrayList<>(path));
            return;
        }
        HashSet<Integer> tmp = new HashSet<>(sets);
        for(int i : tmp){
            path.add(i);
            sets.remove(i);
            backtracking(sets);
            sets.add(i);
            path.remove(path.size() - 1);
        }
    }
}
```

更优秀的，不用哈希表，用下标数组记录。

```java
class Solution {
    List<Integer> path; 
    List<List<Integer>> res;
    public List<List<Integer>> permute(int[] nums) {
        // 全排列，则固定长度，包括顺序，其实就是一个N叉树
        path = new ArrayList<>();
        res = new ArrayList<>();
        int used[] = new int[nums.length];
        for(int i = 0; i < used.length; i ++) used[i] = 0;
        backtracking(nums, used);
        return res;
    }
    private void backtracking(int[] nums, int[] used){
        if(path.size() == nums.length){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < nums.length; i ++){
            if(used[i] == 1) continue;
            path.add(nums[i]);
            used[i] = 1;
            backtracking(nums, used);
            path.remove(path.size() - 1);
            used[i] = 0;
        }
    }
}
```

