# [51. N 皇后](https://leetcode.cn/problems/n-queens/)

按层回溯，每一个格子都试试，是否填充按照 行、列、斜线 是否有queen来划分。递归深度其实就是棋盘高度。

```java
class Solution {
    List<List<String>> res;
    List<String> matrixStr;
    public List<List<String>> solveNQueens(int n) {
        int col[] = new int[n];
        int row[] = new int[n];
        int matrix[][] = new int[n][n];
        res = new ArrayList<>();
        matrixStr = new ArrayList<>();
        backtracking(col, row, matrix, 0);
        return res;
    }
    private void backtracking(int col[], int row[], int matrix[][], int line){
        if(line >= col.length){
            // 到底可以结算了
            for(int i = 0; i < row.length; i ++){
                StringBuilder str = new StringBuilder();
                for(int j = 0; j < col.length; j ++){
                    if(matrix[i][j] == 0){
                        str.append('.');
                    }
                    else{
                        str.append('Q');
                    }
                }
                matrixStr.add(str.toString());
            }
            res.add(new ArrayList<>(matrixStr));
            matrixStr.clear();
        }
        for(int i = 0; i < col.length; i ++){
            // 行列
            if(col[i] == 1 || row[line] == 1) continue;
            // 斜线
            if(!isRightPos(line, i, matrix)) continue;

            col[i] = 1; row[line] = 1;
            matrix[line][i] = 1;
            backtracking(col, row, matrix, line+1);
            col[i] = 0; row[line] = 0;
            matrix[line][i] = 0;
        }
    }
    private boolean isRightPos(int i, int j, int matrix[][]){
        int posi = i, posj = j;
        // 向左上搜索
        while (posi >= 0 && posj >= 0) {
            if(matrix[posi][posj] == 1) return false;
            posi --;
            posj --;
        }
        // 向右上搜索
        posi = i; posj = j;
        while (posi >= 0 && posj < matrix.length) {
            if(matrix[posi][posj] == 1) return false;
            posi --;
            posj ++;
        }
        return true;
    }
}
```

