# [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

首先上一个经典的回溯做法，虽然会超时，因为很多地方可以优化，时间O(n! × n)，空间O(n)
```java
class Solution {
    List<String> path;
    List<List<String>> res;
    public List<String> findItinerary(List<List<String>> tickets) {
        // JFK开始
        path = new ArrayList<>();
        res = new ArrayList<>();
        int used[] = new int[tickets.size()];
        backtracking("JFK", tickets, used);
        // 这里的字典序排序很重要
        Collections.sort(res, (a, b) -> {
            // a, b 分别是两个List<String>
            int minSize = Math.min(a.size(), b.size());
            for (int i = 0; i < minSize; i++) {
                // 这里相当于调用的是 String.compareTo
                int cmp = a.get(i).compareTo(b.get(i));
                if (cmp != 0) return cmp;
            }
            return a.size() - b.size();
        });
        return res.get(0);
    }

    private void backtracking(String from, List<List<String>> tickets, int used[]){
        if(path.size() == tickets.size() + 1){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = 0; i < tickets.size(); i ++){
            List<String> ticket = tickets.get(i);
            if(used[i] == 1) continue;
            if(ticket.get(0).equals(from)){
                used[i] = 1;
                if(path.isEmpty()) path.add(from);
                path.add(ticket.get(1));
                backtracking(ticket.get(1), tickets, used);
                path.remove(path.size() - 1);
                used[i] = 0;
            }
        }
    }
}
```

剪枝，用邻接表，但是还是O(n!)
```java
class Solution {
    List<String> result;
    Map<String, List<String>> graph;
    Map<String, boolean[]> used;
    
    public List<String> findItinerary(List<List<String>> tickets) {
        // 构建邻接表并排序
        graph = new HashMap<>();
        used = new HashMap<>();
        
        for (List<String> ticket : tickets) {
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.putIfAbsent(from, new ArrayList<>());
            graph.get(from).add(to);
        }
        
        // 对每个起点的目的地列表排序
        for (String key : graph.keySet()) {
            Collections.sort(graph.get(key));
            used.put(key, new boolean[graph.get(key).size()]);
        }
        
        result = new ArrayList<>();
        result.add("JFK");
        backtracking("JFK", tickets.size());
        return result;
    }
    
    private boolean backtracking(String from, int ticketsLeft) {
        if (ticketsLeft == 0) {
            return true; // 找到解
        }
        
        if (!graph.containsKey(from)) {
            return false;
        }
        
        List<String> destinations = graph.get(from);
        boolean[] visited = used.get(from);
        
        for (int i = 0; i < destinations.size(); i++) {
            if (!visited[i]) {
                String to = destinations.get(i);
                visited[i] = true;
                result.add(to);
                
                if (backtracking(to, ticketsLeft - 1)) {
                    return true; // 找到解，直接返回
                }
                
                // 回溯
                result.remove(result.size() - 1);
                visited[i] = false;
            }
        }
        return false;
    }
}

```

### 1. **数据结构优化**

- 使用 `Map<String, PriorityQueue<String>>` 构建图
- `PriorityQueue` 自动按字典序排序目的地
- 避免手动排序所有结果

### 2. **算法优化**

- 使用 **Hierholzer算法** 寻找欧拉路径
- 时间复杂度：O(E log E)，其中 E 是边的数量
- 原解法最坏情况是 O(n!)，优化后是指数级提升

### 3. **剪枝优化**

- 优先选择字典序小的路径，天然得到最小字典序结果
- 不需要生成所有路径再比较

```java
class Solution {
    Map<String, PriorityQueue<String>> graph;
    List<String> result;
    
    public List<String> findItinerary(List<List<String>> tickets) {
        // 构建邻接表，使用优先队列自动按字典序排序
        graph = new HashMap<>();
        result = new LinkedList<>();
        
        // 构建图
        for (List<String> ticket : tickets) {
            String from = ticket.get(0);
            String to = ticket.get(1);
            graph.putIfAbsent(from, new PriorityQueue<>());
            graph.get(from).offer(to);
        }
        
        // Hierholzer算法（欧拉路径）
        dfs("JFK");
        
        // 因为是逆序添加的，需要反转
        Collections.reverse(result);
        return result;
    }
    
    private void dfs(String airport) {
        PriorityQueue<String> destinations = graph.get(airport);
        
        // 深度优先遍历所有目的地
        while (destinations != null && !destinations.isEmpty()) {
            String next = destinations.poll(); // 按字典序取出最小的
            dfs(next);
        }
        
        // 后序遍历添加节点（逆序）
        result.add(airport);
    }
}

```

