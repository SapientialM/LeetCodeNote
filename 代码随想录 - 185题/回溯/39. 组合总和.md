# [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

```java
class Solution {
    HashSet<List<Integer>> set;
    List<Integer> path;
    int minCadidate;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        // 树形结构，且无重复限制
        List<List<Integer>> res = new ArrayList<>();
        path = new ArrayList<>();
        set = new HashSet<>();
        for(int i : candidates){
            minCadidate = Math.min(i, minCadidate);
        }
        backtracking(candidates, target);
        for(List<Integer> i : set){
            res.add(i);
        }
        return res;
    }
    private void backtracking(int[] candidates, int remaining){
        if(remaining == 0){
            List<Integer> tmp = new ArrayList<>(path);
            tmp.sort((a,b)->a-b);
            set.add(tmp);
            return;
        }
        if(remaining < 0 || remaining < minCadidate){
            return;
        }
        
        for(int i : candidates){
            path.add(i);
            backtracking(candidates, remaining-i);
            path.remove(path.size()-1);
        }
    }
}
```

但是实际上还可以优化：

### 1. **去除重复组合的优化**
当前：使用HashSet去重 → 效率低
优化：**排序 + 控制起始索引** 避免重复

### 2. **剪枝优化**
当前：在递归底部剪枝
优化：**在循环中提前剪枝**，减少递归调用

### 3. **避免不必要的排序**
当前：每个结果都要排序后加入set
优化：**保持路径有序**，直接生成有序组合

## 优化后的核心代码：

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // 排序便于剪枝
        backtracking(candidates, target, 0, new ArrayList<>(), res);
        return res;
    }
    
    private void backtracking(int[] candidates, int remaining, int start, 
                            List<Integer> path, List<List<Integer>> res) {
        if (remaining == 0) {
            res.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = start; i < candidates.length; i++) {
            if (remaining - candidates[i] < 0) break; // 提前剪枝
            
            path.add(candidates[i]);
            backtracking(candidates, remaining - candidates[i], i, path, res); // 从i开始，允许重复
            path.remove(path.size() - 1);
        }
    }
}
```

