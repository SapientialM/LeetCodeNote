# [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

考验对二叉树的理解。

## **问题理解**

**题目**：给定一个二叉树，我们在树的节点上安装摄像头。每个摄像头可以监视其**父节点、自身、直接子节点**。计算覆盖所有节点所需的最小摄像头数量。

**难点**：如何用最少的摄像头覆盖所有节点，特别是处理不同状态的关系。

---

## **核心思路：后序遍历 + 状态标记**

### **三种状态定义**
```java
// 0: 该节点未被覆盖（需要父节点或自己安装摄像头）
// 1: 该节点已被覆盖（子节点或自己安装了摄像头）  
// 2: 该节点安装了摄像头
```

### **贪心策略**
从底向上遍历，让**父节点来覆盖子节点**，这样能用更少的摄像头覆盖更多节点。

---

## **递归逻辑**

对于每个节点，考虑其左右子节点的状态：

1. **左右子节点都有覆盖** → 当前节点**未被覆盖**（状态0）
   - 让父节点来覆盖当前节点

2. **至少一个子节点未被覆盖** → 当前节点**必须安装摄像头**（状态2）
   - 摄像头数+1

3. **至少一个子节点有摄像头** → 当前节点**已被覆盖**（状态1）

---

## **代码实现**

```java
class Solution {
    private int result = 0;
    
    public int minCameraCover(TreeNode root) {
        // 如果根节点未被覆盖，需要额外加一个摄像头
        if (dfs(root) == 0) {
            result++;
        }
        return result;
    }
    
    /**
     * 后序遍历，返回节点状态
     * 0: 未被覆盖
     * 1: 已被覆盖  
     * 2: 有摄像头
     */
    private int dfs(TreeNode node) {
        if (node == null) {
            return 1; // 空节点视为已被覆盖，不需要处理
        }
        
        int left = dfs(node.left);
        int right = dfs(node.right);
        
        // 情况1：左右子节点都有覆盖
        // 当前节点未被覆盖，让父节点处理
        if (left == 1 && right == 1) {
            return 0;
        }
        
        // 情况2：至少一个子节点未被覆盖
        // 当前节点必须安装摄像头
        if (left == 0 || right == 0) {
            result++;
            return 2;
        }
        
        // 情况3：至少一个子节点有摄像头
        // 当前节点已被覆盖
        if (left == 2 || right == 2) {
            return 1;
        }
        
        // 只要测试用例没有问题就不会执行到这里
        return -1;
    }
}
```

---

## **详细执行过程**

以二叉树 `[0,0,null,0,0]` 为例：
```
    0
   /
  0
 / \
0   0
```

**后序遍历过程**：
1. 最左下节点0：左右空 → 状态1（被覆盖）
2. 最右下节点0：左右空 → 状态1（被覆盖）  
3. 中间节点0：左右都是1 → 状态0（未被覆盖）
4. 根节点的左子节点0：左右有0 → 状态2（安装摄像头）
5. 根节点0：左子节点是2 → 状态1（被覆盖）

**结果**：1个摄像头

---

## **状态转换表**

| 左子节点状态 | 右子节点状态 | 当前节点动作        | 摄像头计数 |
| ------------ | ------------ | ------------------- | ---------- |
| 1            | 1            | 状态0（未覆盖）     | +0         |
| 0            | 任意         | 状态2（安装摄像头） | +1         |
| 任意         | 0            | 状态2（安装摄像头） | +1         |
| 2            | 任意         | 状态1（被覆盖）     | +0         |
| 任意         | 2            | 状态1（被覆盖）     | +0         |

---

## **关键点总结**

1. **后序遍历**：从叶子节点开始处理，保证子节点状态已知
2. **状态定义**：明确三种状态的含义和转换关系
3. **贪心思想**：尽量让父节点覆盖子节点，减少摄像头数量
4. **根节点特殊处理**：如果根节点未被覆盖，需要额外摄像头

**时间复杂度**：O(n)  
**空间复杂度**：O(h)，h为树高

这个解法利用了树的后序遍历特性，通过状态标记实现了最优的摄像头布置策略！