# [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

除开mark，其他的我想到了。但是其实举例`100`就知道，需要这个mark，一旦降位到9，之前的位数就一定是9才是最近的。

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        // 从右往左，如果我比你小，那就取，nums[i-1] --; nums[i] = 9;
        // 以此类推
        int val = n;
        int mark = -1;
        List<Integer> nums = new ArrayList<>();
        while (val > 0) {
            nums.add(val%10);
            val /= 10;
        }
        for(int i = 0; i < nums.size()-1; i ++){
            if(nums.get(i) < nums.get(i+1)){
                mark = i; // 从这里开始，前面的都要变9
                nums.set(i, 9);
                nums.set(i+1, nums.get(i+1) - 1);
            }
        }
        while(nums.size() > 1 && nums.getLast() == 0){
            nums.remove(nums.size() - 1);
        }
        for(int i = 0; i < mark; i ++){
            nums.set(i, 9);
        }
        int res = 0;
        int iterate = 1;
        for(int i : nums){
            res += i * iterate;
            iterate *= 10;
        }
        return res;
    }
}
```

简洁版本，对于数组转换用了String的包装：
```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        if (n < 10) return n; // 个位数直接返回
        
        char[] digits = String.valueOf(n).toCharArray();
        int mark = digits.length; // 标记从哪个位置开始变成9
        
        // 从右往左扫描，找到第一个不满足递增的位置
        for (int i = digits.length - 1; i > 0; i--) {
            if (digits[i] < digits[i - 1]) {
                mark = i; // 从这个位置开始都要变成9
                digits[i - 1]--; // 前一位减1
            }
        }
        
        // 从mark位置开始，后面所有位都变成9
        for (int i = mark; i < digits.length; i++) {
            digits[i] = '9';
        }
        
        return Integer.parseInt(new String(digits));
    }
}

```

