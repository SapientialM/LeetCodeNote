# [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

不要想那么复杂，我们只需要统计向下摆动结束和向上摆动结束的序列即可解决这个问题。

**例子**：

> **数组**: `[1,17,5,10,13,15,10,5,16,8]`
>
> **初始化**: `up = 1`, `down = 1`
>
> ### **逐步分析**：
>
> 1. **1→17** ( ↗ ) 上升
>    - `up = down + 1 = 1 + 1 = 2`
>    - `down = down = 1`
>    - 序列: `1→17`
>
> 2. **17→5** ( ↘ ) 下降
>    - `down = up + 1 = 2 + 1 = 3`
>    - `up = up = 2`
>    - 序列: `1→17→5`
>
> 3. **5→10** ( ↗ ) 上升
>    - `up = down + 1 = 3 + 1 = 4`
>    - `down = down = 3`
>    - 序列: `1→17→5→10`
>
> 4. **10→13** ( ↗ ) 上升
>    - 由于是连续上升，`up` 保持不变
>    - `up = up = 4`
>    - `down = down = 3`
>    - 序列: `1→17→5→10` (不接13)
>
> 5. **13→15** ( ↗ ) 上升
>    - 连续上升，`up` 保持不变
>    - `up = up = 4`
>    - `down = down = 3`
>    - 序列: `1→17→5→10` (不接15)
>
> 6. **15→10** ( ↘ ) 下降
>    - `down = up + 1 = 4 + 1 = 5`
>    - `up = up = 4`
>    - 序列: `1→17→5→10→15→10`
>
> 7. **10→5** ( ↘ ) 下降
>    - 连续下降，`down` 保持不变
>    - `down = down = 5`
>    - `up = up = 4`
>    - 序列: `1→17→5→10→15→10` (不接5)
>
> 8. **5→16** ( ↗ ) 上升
>    - `up = down + 1 = 5 + 1 = 6`
>    - `down = down = 5`
>    - 序列: `1→17→5→10→15→10→5→16`
>
> 9. **16→8** ( ↘ ) 下降
>    - `down = up + 1 = 6 + 1 = 7`
>    - `up = up = 6`
>    - 序列: `1→17→5→10→15→10→5→16→8`
>
> **最终结果**: `max(up, down) = max(6, 7) = 7`

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length < 2) {
            return nums.length;
        }
        
        int up = 1;    // 以向上摆动结束的最长子序列长度
        int down = 1;  // 以向下摆动结束的最长子序列长度
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                // 当前是向上摆动，更新up
                up = down + 1;
            } else if (nums[i] < nums[i - 1]) {
                // 当前是向下摆动，更新down
                down = up + 1;
            }
            // 如果相等，保持原来的值
        }
        
        return Math.max(up, down);
    }
}

```

