# [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

特简单，就是怕你想不到。

身高相同那我前方多，所以肯定在你后面；

你比我高，那你大概率在我前面；

我前方有N个，那么我就从N位置开始放；

```java
import java.util.*;

class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 按身高降序排列，身高相同按k值升序排列
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) {
                return a[1] - b[1];  // 身高相同，按k升序
            }
            return b[0] - a[0];      // 身高降序
        });
        
        List<int[]> queue = new ArrayList<>();
        
        // 按k值作为索引插入
        for (int[] person : people) {
            queue.add(person[1], person);  // 在k位置插入
        }
        
        // 转换为二维数组返回
        return queue.toArray(new int[people.length][]);
    }
}

```

