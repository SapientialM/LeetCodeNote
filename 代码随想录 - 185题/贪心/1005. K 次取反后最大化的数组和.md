# [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

```java

import java.lang.reflect.Array;class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        // 排序后，你会遇到一些问题
        // 负数足够把 k 花完，那就直接开倒负数
        // 负数没办法把 k 花完，那就正数倒偶数次，从重排后的最小正数开倒（记住！！一定是重排）
        // 负数没办法把 k 花完，但是存在 0，则无损开倒
        int remaining = k;
        for(int i = 0; i < nums.length; i ++){
            if(remaining == 0) break;
            if(nums[i] < 0){
                remaining --;
                nums[i] = (-nums[i]);
            }
            else if(nums[i] == 0){
                remaining = 0;
                break;
            }
            else{
                remaining = remaining % 2;
                // 重新寻找最小正数
                if(remaining == 1){
                    int minPos = findMinPos(nums, i);
                    nums[minPos] = (-nums[minPos]);
                }
                break;
            }
            if(i == nums.length - 1){
                // 到底了但是还没用完
                // 再来一次就好了
                i --;
            }
        }
        int sum = 0;
        for(int i : nums){
            sum += i;
        }
        return sum;
    }
    private int findMinPos(int[] nums, int index){
        int minValue = nums[index];
        int minPos = index;
        int pos = index - 1;
        while (pos >= 0 && nums[pos] < minValue) {
            minPos = pos;
            minValue = nums[pos];
            pos --;
        }
        return minPos;
    }
}
```

这只是第一版，可以优化，主要问题在于逻辑有些复杂，特别是处理剩余翻转次数时的边界情况。但是吧，我觉得这个思路没上面那个好想。
```java
import java.util.Arrays;

class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        // 按绝对值从大到小排序，这样能保证优先翻转绝对值大的负数
        nums = Arrays.stream(nums)
                .boxed()
                .sorted((a, b) -> Math.abs(b) - Math.abs(a))
                .mapToInt(Integer::intValue)
                .toArray();
        
        // 第一步：优先翻转负数（因为能带来最大收益）
        for (int i = 0; i < nums.length && k > 0; i++) {
            if (nums[i] < 0) {
                nums[i] = -nums[i];
                k--;
            }
        }
        
        // 第二步：如果还有剩余翻转次数（k为奇数），翻转最小的数
        if (k % 2 == 1) {
            nums[nums.length - 1] = -nums[nums.length - 1];
        }
        
        // 计算总和
        return Arrays.stream(nums).sum();
    }
}

```

