# [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

模拟一个单调栈，然后遍历每日温度，如果比栈顶小则存入，如果比栈顶大则弹出。

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Pair<Integer, Integer>> stack = new Stack<>();
        int res[] = new int[temperatures.length];
        for(int i = 0; i < temperatures.length; i ++){
            int temp = temperatures[i];
            if(stack.isEmpty()){
                stack.push(new Pair<>(temp, i));
            }
            else{
                if(temp < stack.peek().getKey()){
                    stack.push(new Pair<>(temp, i));
                }
                else{
                    while (!stack.isEmpty() && temp > stack.peek().getKey()) {
                        Pair<Integer, Integer> pair = stack.pop();
                        res[pair.getValue()] = i - pair.getValue();
                    }
                    stack.push(new Pair<>(temp, i));
                }
            }
        }
        while (!stack.isEmpty()){
            Pair<Integer, Integer> pair = stack.pop();
            res[pair.getValue()] = 0;
        }
        return res;
    }
}
```

可以优化，不用 pair，Deque代替Stack：
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] res = new int[n];
        Deque<Integer> stack = new ArrayDeque<>(); // 使用 Deque 替代 Stack，因为 ArrayDeque 是非同步的，更快
        
        for (int i = 0; i < n; i++) {
            int currentTemp = temperatures[i];
            
            // 弹出所有比当前温度低的，并计算天数差
            while (!stack.isEmpty() && currentTemp > temperatures[stack.peek()]) {
                int prevIndex = stack.pop();
                res[prevIndex] = i - prevIndex;
            }
            
            stack.push(i); // 只存储索引，不需要 Pair
        }
        // 栈中剩余的默认就是 0，不需要额外处理
        return res;
    }
}

```

