# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

感觉自己做复杂了

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root.left == null && root.right == null) return true;
        // 分别对两个子树做层序遍历即可
        Queue<TreeNode> leftQ = new ArrayDeque<>();
        Queue<TreeNode> rightQ = new ArrayDeque<>();
        if(root.left != null && root.right == null || root.left == null && root.right != null){
            return false;
        }
        leftQ.offer(root.left);
        rightQ.offer(root.right);
        while (!leftQ.isEmpty() && !rightQ.isEmpty()) {
            TreeNode left = leftQ.poll();
            TreeNode right = rightQ.poll();
            if(left.val != right.val){
                return false;
            }
            if(left.left != null){
                leftQ.offer(left.left);
                if(right.right == null){
                    return false;
                }
                rightQ.offer(right.right);
            }
            else if(right.right != null){
                return false;
            }
            if(left.right != null){
                leftQ.offer(left.right);
                if(right.left == null){
                    return false;
                }
                rightQ.offer(right.left);
            }
            else if(right.left != null){
                return false;
            }
        }
        if(leftQ.isEmpty() && rightQ.isEmpty()){
            return true;
        }
        return false;
    }
}
```

递归其实可以很简单的。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root.left, root.right);
    }

    public boolean check(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
    }
}
```

迭代其实没有那么复杂，要么全空，要么有空就完蛋

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    public boolean check(TreeNode u, TreeNode v) {
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(u);
        q.offer(v);
        while (!q.isEmpty()) {
            u = q.poll();
            v = q.poll();
            if (u == null && v == null) {
                continue;
            }
            if ((u == null || v == null) || (u.val != v.val)) {
                return false;
            }

            q.offer(u.left);
            q.offer(v.right);

            q.offer(u.right);
            q.offer(v.left);
        }
        return true;
    }
}
```

