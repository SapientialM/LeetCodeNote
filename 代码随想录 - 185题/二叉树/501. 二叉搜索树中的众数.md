#  # [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)的变体，不需要构建数组，把数组变为HashMap就行，当然正常BST不会包含重复数。

```java

import java.util.Map.Entry;
class Solution {
    public int[] findMode(TreeNode root) {
        HashMap<Integer, Integer> map = new HashMap<>();
        traversal(root, map);
        List<Integer> resList = new ArrayList<>();
        int maxValue = Integer.MIN_VALUE;
        for(Entry<Integer, Integer> en : map.entrySet()){
            if(en.getValue() == maxValue){
                resList.add(en.getKey());
            }
            else if(en.getValue() > maxValue){
                maxValue = en.getValue();
                resList.clear();
                resList.add(en.getKey());
            }
            
        }
        int res[] = resList.stream().mapToInt(Integer::intValue).toArray();
        return res;
    }
    public void traversal(TreeNode node, HashMap<Integer, Integer> map){
        if(node == null) return;
        traversal(node.left, map);
        if(map.containsKey(node.val)){
            map.replace(node.val, map.get(node.val) + 1);
        }
        else{
            map.put(node.val, 1);
        }
        traversal(node.right, map);
    }
}
```

但是感觉这个方法有点烂？而且时间复杂度O(n)但3n+k，空间复杂度O(n)但3n。

因为是BST，其实可以用上这个特点，如果值重复，那么节点必连续，得到时间复杂度O(n)即n，空间复杂度O(n)但2n。

```java
import java.util.*;

class Solution {
    private int maxCount = 0; // 最大频率
    private int count = 0; // 统计频率
    private TreeNode pre = null;
    private List<Integer> result = new ArrayList<>();
    
    private void searchBST(TreeNode cur) {
        if (cur == null) return;

        searchBST(cur.left);       // 左
                                   // 中
        if (pre == null) { // 第一个节点
            count = 1;
        } else if (pre.val == cur.val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.add(cur.val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.add(cur.val);
        }

        searchBST(cur.right);      // 右
    }

    public int[] findMode(TreeNode root) {
        count = 0;
        maxCount = 0;
        pre = null; // 记录前一个节点
        result.clear();

        searchBST(root);
        
        // 将 List<Integer> 转换为 int[]
        int[] res = new int[result.size()];
        for (int i = 0; i < result.size(); i++) {
            res[i] = result.get(i);
        }
        return res;
        
        // 或者使用 Stream API（更简洁）
        // return result.stream().mapToInt(Integer::intValue).toArray();
    }
}

```

