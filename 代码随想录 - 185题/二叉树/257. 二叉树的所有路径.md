# [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

我的方法有点笨，这么做也是 O(N*N)

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null) return res;
        
        // 使用 Stack 保存节点和对应的路径
        Stack<Pair<TreeNode, Stack<Integer>>> stack = new Stack<>();
        
        // 初始化根节点的路径
        Stack<Integer> initialPath = new Stack<>();
        initialPath.push(root.val);
        stack.push(new Pair<>(root, initialPath));
        
        while (!stack.isEmpty()) {
            Pair<TreeNode, Stack<Integer>> pair = stack.pop();
            TreeNode node = pair.getKey();
            Stack<Integer> path = pair.getValue();
            
            // 如果是叶子节点，构建路径字符串
            if (node.left == null && node.right == null) {
                StringBuilder sb = new StringBuilder();
                // 将路径栈转换为列表（逆序）
                List<Integer> pathList = new ArrayList<>(path);
                for (int i = 0; i < pathList.size(); i++) {
                    sb.append(pathList.get(i));
                    if (i < pathList.size() - 1) {
                        sb.append("->");
                    }
                }
                res.add(sb.toString());
            }
            
            // 处理右子树（先压入右子树，因为栈是后进先出）
            if (node.right != null) {
                Stack<Integer> rightPath = new Stack<>();
                rightPath.addAll(path); // 复制当前路径
                rightPath.push(node.right.val); // 添加右子节点值
                stack.push(new Pair<>(node.right, rightPath));
            }
            
            // 处理左子树（后压入左子树，这样会先被处理）
            if (node.left != null) {
                Stack<Integer> leftPath = new Stack<>();
                leftPath.addAll(path); // 复制当前路径
                leftPath.push(node.left.val); // 添加左子节点值
                stack.push(new Pair<>(node.left, leftPath));
            }
        }
        
        return res;
    }
}
```

当然遇到树，很多时候递归真的很有用，主要是简单，但是复杂度也是 O( N * N )，空间复杂度也是 O( N * N ) 

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<String>();
        constructPaths(root, "", paths);
        return paths;
    }

    public void constructPaths(TreeNode root, String path, List<String> paths) {
        if (root != null) {
            StringBuffer pathSB = new StringBuffer(path);
            pathSB.append(Integer.toString(root.val));
            if (root.left == null && root.right == null) {  // 当前节点是叶子节点
                paths.add(pathSB.toString());  // 把路径加入到答案中
            } else {
                pathSB.append("->");  // 当前节点不是叶子节点，继续递归遍历
                constructPaths(root.left, pathSB.toString(), paths);
                constructPaths(root.right, pathSB.toString(), paths);
            }
        }
    }
}
```

DFS + 回溯有奇效，空间复杂度可以优化到 O(h)

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null) return res;
        
        List<Integer> path = new ArrayList<>();
        dfs(root, path, res);
        return res;
    }
    
    private void dfs(TreeNode node, List<Integer> path, List<String> res) {
        // 将当前节点加入路径
        path.add(node.val);
        
        // 如果是叶子节点，构建路径字符串
        if (node.left == null && node.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < path.size(); i++) {
                sb.append(path.get(i));
                if (i < path.size() - 1) {
                    sb.append("->");
                }
            }
            res.add(sb.toString());
        }
        
        // 递归处理左子树
        if (node.left != null) {
            dfs(node.left, path, res);
        }
        
        // 递归处理右子树
        if (node.right != null) {
            dfs(node.right, path, res);
        }
        
        // 回溯：移除当前节点
        path.remove(path.size() - 1);
    }
}

```

