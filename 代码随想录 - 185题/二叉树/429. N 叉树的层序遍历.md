# [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

层序遍历的逻辑实际上并不会因为分叉数量而变化，我们可以根据原有的代码进行逻辑上的修改：
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        if(root == null) return new ArrayList<>();
        List<List<Integer>> resList = new ArrayList<>();
        Queue<Node> nodeQ = new ArrayDeque<>();
        nodeQ.offer(root);
        while (!nodeQ.isEmpty()) {
            int size = nodeQ.size();
            List<Integer> tmpList = new ArrayList<>();
            for(int i = 0; i < size; i ++){
                Node node = nodeQ.poll();
                tmpList.add(node.val);
                // 原本是左右节点，这里遍历children
                for(int j = 0; j < node.children.size(); j ++){
                    nodeQ.offer(node.children.get(j));
                }
            }
            resList.add(tmpList);
        }
        return resList;
    }
}
```

