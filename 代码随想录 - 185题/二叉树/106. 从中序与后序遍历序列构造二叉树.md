# [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

先找尾节点，然后两个数组一起切分，递归。

![106.从中序与后序遍历序列构造二叉树](https://file1.kamacoder.com/i/algo/20210203154249860.png)

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder.length == 0 || postorder.length == 0) return null;
        // 后序遍历最后一个作为根节点
        // 根节点可以分左右树
        int root = postorder[postorder.length - 1];
        TreeNode node = new TreeNode(root);
        int mid = 0;
        while (root != inorder[mid]) {
            mid ++;
        }
        node.left = buildTree(Arrays.copyOfRange(inorder, 0, mid), 
        Arrays.copyOfRange(postorder, 0, mid));
        node.right = buildTree(Arrays.copyOfRange(inorder, mid + 1, inorder.length), 
        Arrays.copyOfRange(postorder, mid, postorder.length-1));
        return node;
    }
}
```

