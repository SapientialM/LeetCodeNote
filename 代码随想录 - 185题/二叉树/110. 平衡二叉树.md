# [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

其实相当于深度计算的变体

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        // 毕竟是做每个节点的左右子树差，做递归会好点
        if(calDepth(root) == -1){
            return false;
        }
        else{
            return true;
        }
    }
    int calDepth(TreeNode root){
        if(root == null){
            return 0;
        }
        int leftDepth = calDepth(root.left);
        int rightDepth = calDepth(root.right);
        if(leftDepth == -1 || rightDepth == -1){
            return -1;
        }
        if(Math.abs(leftDepth - rightDepth) > 1){
            return -1;
        }
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

