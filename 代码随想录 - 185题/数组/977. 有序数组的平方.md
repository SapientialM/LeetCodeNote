# [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

最简单是平方后暴力排序，O(n+logn)，其次就是找到0点，然后双指针比较排序，O(2n)。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 非严格递增序列
        // 先找到中点，然后往两边双指针
        if(nums.length == 1){
            return new int[]{nums[0] * nums[0]};
        }
        int pos = 0;
        while(pos < nums.length && nums[pos] < 0){
            pos ++;
        }
        // pos 即第一个非负数
        int left = pos - 1;
        int right = pos;
        int[] res = new int[nums.length];
        int index = 0;
        while (index < nums.length) {
            int leftVal = 0;
            boolean leftIn = false;
            int rightVal = 0;
            boolean rightIn = false;
            if(left > -1){
                leftVal = Math.abs(nums[left]);
                leftIn = true;
            }
            if(right < nums.length){
                rightVal = Math.abs(nums[right]);
                rightIn = true;
            }
            if(leftIn && leftVal <= rightVal || !rightIn){
                res[index ++] = leftVal * leftVal;
                left --;
            }
            else{
                res[index ++] = rightVal * rightVal;
                right ++;
            }
        }
        return res;
    }
}
```

当前找0点纯粹没事干。其实可以反向思考，两端开始找不就好了，还不用考虑那么多。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int res[] = new int[nums.length];
        int be = 0; int en = nums.length - 1;
        int index = nums.length - 1;
        while (index >= 0) {
            int left = Math.abs(nums[be]);
            int right = Math.abs(nums[en]);
            if(left > right){
                be ++;
                res[index --] = left * left;
            }
            else{
                en --;
                res[index --] = right * right;
            }
        }
        return res;
    }
}
```

