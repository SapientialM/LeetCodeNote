> - [995. K 连续位的最小翻转次数](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/)
> - 

## 1. 差分数组（Difference Array）

**基本思想**：  
当我们需要对数组的某个区间 `[l, r]` 进行**统一增加/减少**操作时，如果直接遍历区间修改，每次 O(K)，总复杂度可能很高。  
差分数组可以让我们在 O(1) 时间内标记这个操作，最后再通过前缀和还原出每个位置的实际操作次数。

**差分数组定义**：  
设原操作次数数组为 `f`（长度 n），差分数组 `diff` 长度 n+1，满足：
- `diff[i] = f[i] - f[i-1]`（对 i ≥ 1），`diff[0] = f[0]`
- 对区间 `[l, r]` 增加 1：`diff[l] += 1`, `diff[r+1] -= 1`
- 通过 `f[i] = f[i-1] + diff[i]` 还原 `f`

**在这个问题中的应用**：  
翻转操作等价于对区间 `[i, i+K-1]` 的每个位置增加 1 次翻转次数（奇数次翻转改变值，偶数次不变）。  
我们可以用 `flipCount` 表示到当前位置为止的累计翻转次数（模 2 判断当前数字实际是 0 还是 1）。

---

## 2. 队列（Queue）

**为什么需要队列**：  
当我们从左到右遍历时，在位置 `i` 开始的翻转，其影响范围只到 `i+K-1`。  
在位置 `j` 时，所有起点在 `j-K+1` 之前的翻转已经不再影响 `j`。  
所以可以用队列保存**当前影响我的翻转操作的起始位置**，队列长度就是当前累计的未结束的翻转次数。

**队列的作用**：  
- 入队：在位置 `i` 决定翻转时，将 `i` 加入队列
- 出队：当队首的翻转操作已经对当前位置无影响时（即 `queue[0] + K <= i`），出队
- 当前翻转次数奇偶性 = 队列长度 % 2

---

## 3. 结合使用思路

我们可以把差分数组和队列思想融合成一种更简单的实现：

**核心判断逻辑**：  
设 `flip` 表示当前位置的累计翻转次数的奇偶性（0 表示偶数次，1 表示奇数次）。  
实际当前数字 = 原数字 `nums[i]` XOR `flip`。

- 如果实际数字是 0，则必须翻转以当前位置开始的 K 长度子数组
- 翻转时，`flip ^= 1`，并记录这个翻转的结束位置 `i+K`（将来在这个位置之后，这次翻转的影响要取消）
- 用一个队列（或变量+数组）记录在哪些位置需要取消翻转
