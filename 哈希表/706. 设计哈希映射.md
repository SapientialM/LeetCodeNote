# **[706. 设计哈希映射](https://leetcode.cn/problems/design-hashmap/)**

```java
/**
 * 使用链地址法实现的哈希表
 * 每个桶使用LinkedList存储键值对，解决哈希冲突
 */
class MyHashMap {
    /**
     * 内部类：表示键值对
     */
    private class Pair {
        private int key;
        private int value;

        // 构造函数
        public Pair(int key, int value) {
            this.key = key;
            this.value = value;
        }

        // 获取键
        public int getKey() {
            return key;
        }

        // 获取值
        public int getValue() {
            return value;
        }

        // 设置值（用于更新操作）
        public void setValue(int value) {
            this.value = value;
        }
    }

    // 哈希表的基础大小（桶的数量），选择质数可以减少哈希冲突
    private static final int BASE = 769;
    
    // 哈希表数据存储结构：数组 + 链表（链地址法）
    private LinkedList[] data;

    /** 初始化哈希表 */
    public MyHashMap() {
        // 创建BASE个桶
        data = new LinkedList[BASE];
        // 为每个桶初始化一个LinkedList
        for (int i = 0; i < BASE; ++i) {
            data[i] = new LinkedList<Pair>();
        }
    }
    
    /**
     * 插入键值对
     * @param key 键
     * @param value 值（总是非负）
     */
    public void put(int key, int value) {
        // 1. 计算哈希值，确定桶的位置
        int h = hash(key);
        
        // 2. 遍历该桶中的链表，检查key是否已存在
        Iterator<Pair> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Pair pair = iterator.next();
            // 如果找到相同的key，更新value并返回
            if (pair.getKey() == key) {
                pair.setValue(value);
                return;
            }
        }
        
        // 3. 如果key不存在，在链表末尾添加新的键值对
        data[h].offerLast(new Pair(key, value));
    }
    
    /**
     * 获取指定key对应的值
     * @param key 要查找的键
     * @return 对应的值，如果不存在返回-1
     */
    public int get(int key) {
        // 1. 计算哈希值，确定桶的位置
        int h = hash(key);
        
        // 2. 遍历该桶中的链表，查找key
        Iterator<Pair> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Pair pair = iterator.next();
            // 如果找到key，返回对应的value
            if (pair.getKey() == key) {
                return pair.value;
            }
        }
        
        // 3. 没找到，返回-1
        return -1;
    }
    
    /**
     * 删除指定key的映射
     * @param key 要删除的键
     */
    public void remove(int key) {
        // 1. 计算哈希值，确定桶的位置
        int h = hash(key);
        
        // 2. 遍历该桶中的链表，查找要删除的key
        Iterator<Pair> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Pair pair = iterator.next();
            // 如果找到key，从链表中移除该键值对
            if (pair.key == key) {
                data[h].remove(pair);
                return;
            }
        }
    }

    /**
     * 哈希函数：计算key对应的桶索引
     * @param key 键
     * @return 桶的索引（0 到 BASE-1）
     */
    private static int hash(int key) {
        return key % BASE;
    }
}
```

## 代码解析：

### 1. **数据结构设计**
- **Pair类**：封装键值对，提供getter/setter方法
- **BASE常量**：选择质数769作为桶的数量，减少哈希冲突
- **data数组**：每个元素是一个LinkedList，存储该桶中的所有键值对

### 2. **哈希函数**
```java
private static int hash(int key) {
    return key % BASE;
}
```
- 使用简单的取模运算
- BASE选择质数可以更好地分散键的分布
- 也可以选择使用`Java`内置的`Integer.hashCode()`

### 3. **链地址法解决冲突**
- 当多个key哈希到同一个桶时，使用LinkedList存储
- 每个桶都是一个独立的链表

### 4. **操作时间复杂度**
- **平均情况**：O(1) - 假设哈希函数分布均匀
- **最坏情况**：O(n) - 所有key都哈希到同一个桶

### 5. **优点**
- 实现简单直观
- 自动处理哈希冲突
- 不需要复杂的扩容逻辑（LinkedList自动增长）

### 6. **缺点**
- 链表可能过长，影响性能
- 没有自动扩容机制
- 内存使用相对较高（每个元素都有链表节点开销）
