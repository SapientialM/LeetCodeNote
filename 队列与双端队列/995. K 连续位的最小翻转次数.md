# [995. K 连续位的最小翻转次数](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/)

---

## 1. 核心思路

从左到右遍历数组，保证遍历到的位置最终都变成 1：
- 如果当前位置的值经过之前翻转的影响后是 0，就必须翻转从该位置开始的长度为 K 的子数组
- 用队列记录**翻转操作的开始位置**，当遍历到结束位置（开始位置+K）时，说明这次翻转的影响结束

---

## 2. 算法步骤

**变量定义**：

- `queue`：存储翻转操作的结束位置（即 `start_index + K`）
- `result`：记录翻转次数
- `flip`：当前累计翻转次数的奇偶性（0 表示偶数次，1 表示奇数次）

**遍历过程**（对于每个位置 `i`）：
1. **检查队列**：如果队列非空且队首等于 `i`，说明这个翻转操作的影响到此结束，出队
2. **更新 flip**：`flip = len(queue) % 2`（队列长度模 2）
3. **判断是否需要翻转**：
   - 当前实际值 = `nums[i] ^ flip`
   - 如果实际值是 0：必须翻转
     - 如果 `i + K > n`：返回 -1（剩余长度不足 K）
     - 翻转次数 `result += 1`
     - 将 `i + K` 加入队列（记录结束位置）
     - 由于加入队列，flip 会自动在下一步更新

---

## 3. 详细推演示例

`nums = [0,0,0,1,0,1,1,0], K = 3`

初始化：`queue = [], result = 0`

**i=0**：
- 队列空 → flip=0
- 实际值 = 0^0=0 → 需要翻转
- i+K=3 ≤ 8 → 可以翻转
- result=1, queue=[3], flip=1

**i=1**：
- 队列=[3]，队首≠1 → flip=1
- 实际值=0^1=1 → 不需翻转

**i=2**：
- 队列=[3]，队首≠2 → flip=1
- 实际值=0^1=1 → 不需翻转

**i=3**：
- 队列=[3]，队首=3 → 出队，queue=[]
- flip=0
- 实际值=1^0=1 → 不需翻转

**i=4**：
- 队列空 → flip=0
- 实际值=0^0=0 → 需要翻转
- i+K=7 ≤ 8 → 可以翻转
- result=2, queue=[7], flip=1

**i=5**：
- 队列=[7]，队首≠5 → flip=1
- 实际值=1^1=0 → 需要翻转
- i+K=8 ≤ 8 → 可以翻转
- result=3, queue=[7,8], flip=0（因为队列长度2，模2=0）

**i=6**：
- 队列=[7,8]，队首≠6 → flip=0
- 实际值=1^0=1 → 不需翻转

**i=7**：
- 队列=[7,8]，队首=7 → 出队，queue=[8]
- flip=1
- 实际值=0^1=1 → 不需翻转

**i=8**（越界，结束）

最终结果：**3**

---

## 4. 代码实现

```python
class Solution {
    public int minKBitFlips(int[] nums, int k) {
        // 遍历，记录翻转次数，用队列记录开始翻转位置
        Queue<Integer> posQueue = new ArrayDeque<>();
        int result = 0;
        // 记录翻转奇偶性，0 偶 1 奇，偶数不会变，奇数会变
        int fold = 0;
        for(int i = 0; i < nums.length; i ++){
            int val = nums[i];
            if(!posQueue.isEmpty() && i == posQueue.peek() + k){
                // 翻转完成
                fold = fold ^ 1;
                posQueue.poll();
            }
            if((val ^ fold) == 0){
                if(i + k > nums.length){
                    // 无法翻转
                    return -1;
                }
                // 开始翻转
                posQueue.offer(i);
                fold = fold ^ 1;
                result ++;
            } 
        }
        return result;
    }
}
```

---

## 5. 复杂度分析

- **时间复杂度**：O(n)，每个元素入队出队各一次
- **空间复杂度**：O(k)，队列最多存储 k 个元素
