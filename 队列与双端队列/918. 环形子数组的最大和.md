# [918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

我们需要考虑两种情况：

- 最大子数组会跨界（即跨 0 点）
- 最大子数组不跨界

那么对应的解决方法就是：

- 求解最小子数组，然后：跨界最大子数组和 = 总和 - 最小子数组和
- 求解最大子数组

均使用 Kadane 算法（见补充说明）

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        // 情况1：最大和
        // 锚点立定的前缀和
        int max_ending_here[] = new int[nums.length];
        // 锚点的最大和
        int max_sum[] = new int[nums.length];
        max_ending_here[0] = nums[0];
        max_sum[0] = nums[0];
        
        for(int i = 1; i < nums.length; i ++){
            // 要不要成为锚点
            int value = nums[i];
            if(max_ending_here[i-1] > 0){
                // 前面的前缀有贡献
                max_ending_here[i] = max_ending_here[i-1] + value;
            }
            else{
                // 前面的前缀无贡献，重新划定锚点
                max_ending_here[i] = value;
            }
            // 上一个最大和和当前相比进行更新
            max_sum[i] = Math.max(max_sum[i-1], max_ending_here[i]);
        }
        int sum1 = max_sum[nums.length-1];

        // 情况2：最小和
        int allSum = 0;
        for(int i : nums){
            allSum += i;
        }
        int min_ending_here[] = new int[nums.length];
        int min_sum[] = new int[nums.length];
        min_ending_here[0] = nums[0];
        min_sum[0] = nums[0];

        for(int i = 1; i < nums.length; i ++){
            // 要不要成为锚点
            int value = nums[i];
            if(min_ending_here[i-1] < 0){
                // 前面的前缀有贡献
                min_ending_here[i] = min_ending_here[i-1] + value;
            }
            else{
                // 前面的前缀无贡献，重新划定锚点
                min_ending_here[i] = value;
            }
            // 上一个最大和和当前相比进行更新
            min_sum[i] = Math.min(min_sum[i-1], min_ending_here[i]);
        }
        int sum2 = allSum - min_sum[nums.length-1];
        // 为 0 说明无效
        if(sum2 == 0){
            sum2 = sum1;
        }

        return Math.max(sum1, sum2);
    }
}
```



