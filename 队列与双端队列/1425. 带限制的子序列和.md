# [1425. 带限制的子序列和](https://leetcode.cn/problems/constrained-subsequence-sum/)

```java
class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        int n = nums.length;
        // dp[i] 表示以 nums[i] 结尾的满足条件的子序列的最大和
        // 子序列需要满足：相邻元素在原数组中的下标差 ≤ k
        int[] dp = new int[n];
        
        // 初始化：第一个元素自己就是一个有效的子序列
        dp[0] = nums[0];
        int maxSum = dp[0];  // 记录全局最大和
        
        // 使用单调递减队列来维护 [i-k, i-1] 范围内的最大 dp 值
        // 队列中存储的是下标，对应的 dp 值从队首到队尾递减
        Deque<Integer> deque = new LinkedList<>();
        deque.offerLast(0);  // 初始时将第一个元素的下标加入队列
        
        for (int i = 1; i < n; i++) {
            // 步骤1：移除超出窗口范围的元素
            // 窗口范围是 [i-k, i-1]，所以下标小于 i-k 的元素已经不在窗口内
            while (!deque.isEmpty() && deque.peekFirst() < i - k) {
                deque.pollFirst();
            }
            
            // 步骤2：获取窗口内的最大 dp 值
            // 由于队列是单调递减的，队首就是当前窗口内的最大值
            int windowMax = deque.isEmpty() ? 0 : dp[deque.peekFirst()];
            
            // 步骤3：计算以当前元素结尾的最大和
            // 如果前面的最大和是正数，就接上它；否则就重新开始
            if (windowMax > 0) {
                dp[i] = windowMax + nums[i];  // 接上前面的序列
            } else {
                dp[i] = nums[i];  // 重新开始一个新的序列
            }
            
            // 步骤4：更新全局最大值
            maxSum = Math.max(maxSum, dp[i]);
            
            // 步骤5：维护单调队列的性质
            // 从队尾开始，移除所有 dp 值小于等于当前 dp[i] 的元素
            // 这样可以保证队列始终是单调递减的
            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {
                deque.pollLast();
            }
            
            // 将当前下标加入队列
            deque.offerLast(i);
        }
        
        return maxSum;
    }
}

```

