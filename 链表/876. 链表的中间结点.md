## 876. 链表的中间结点

## 题目描述

给定单链表的头节点 `head`，请找出并返回链表的中间节点。如果链表有两个中间节点（即链表长度为偶数），则返回第二个中间节点。

示例：
```
输入：head = [1,2,3,4,5]
输出：[3,4,5]
解释：链表只有一个中间节点，值为3

输入：head = [1,2,3,4,5,6]
输出：[4,5,6]
解释：链表有两个中间节点，值分别为3和4，我们返回第二个节点
```

## 解题思路

这道题目最经典的解法是使用快慢指针法（也称为"龟兔赛跑"算法）。基本思想是：

1. 初始化两个指针：快指针`fast`和慢指针`slow`，都指向链表头部
2. 快指针每次移动两步，慢指针每次移动一步
3. 当快指针到达链表末尾时，慢指针正好位于中间位置

这种方法只需要一次遍历就能找到中间节点，时间复杂度为O(n)，空间复杂度为O(1)。

## 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        int i = 0;
        while(fast != null){
            if(i % 2 == 1)
                slow = slow.next;
            fast = fast.next;
            i++;
        }
        return slow;
    }
}
```

## 代码解析

这段代码实现了快慢指针的思想，但采用了一种稍微不同的方式：

1. 初始化`fast`和`slow`指针都指向头节点
2. 使用计数器`i`来跟踪遍历的步数
3. 每次`fast`指针移动时，`i`增加1
4. 当`i`为奇数时，`slow`指针才移动一步
5. 这样当`fast`到达末尾时，`slow`正好位于中间位置

这种实现方式本质上与经典快慢指针相同，只是移动`slow`指针的条件不同。经典实现中`fast`每次移动两步，`slow`每次移动一步，而这里是通过计数器来控制`slow`的移动。

## 优化建议

虽然当前代码能够正确解决问题，但可以简化为更经典的快慢指针实现，这样逻辑更清晰，也不需要额外的计数器变量：

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

优化后的代码：
1. 更简洁，不需要计数器变量
2. 快指针每次移动两步，慢指针每次移动一步
3. 当快指针无法继续移动两步时（到达末尾或倒数第二个节点），慢指针正好在中间位置
