## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

## 题目描述

给定一个单链表的头节点 `head`，请判断该链表是否为回文链表。回文链表是指正序和逆序读取结果相同的链表。

示例 1：
```
输入: 1->2->2->1
输出: true
```

示例 2：
```
输入: 1->2
输出: false
```

## 解题思路

### 方法一：数组存储+双指针

最直观的解法是将链表中的值复制到数组中，然后使用双指针法判断数组是否为回文。

具体步骤如下：
1. 遍历链表，将所有节点的值存入一个动态数组（如ArrayList）中
2. 初始化两个指针，一个指向数组头部（front），一个指向数组尾部（back）
3. 比较两个指针指向的元素是否相同：
   - 如果不同，立即返回false
   - 如果相同，则移动指针（front向后移动，back向前移动）
4. 如果所有比较都通过，则返回true

这种方法的时间复杂度是O(n)，空间复杂度也是O(n)，因为需要额外的数组空间存储链表元素。

## 代码实现

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> arr = new ArrayList<Integer>();

        ListNode cur = head;
        while (cur != null) {
            arr.add(cur.val);
            cur = cur.next;
        }

        // 使用双指针判断是否回文
        int front = 0;
        int back = arr.size() - 1;
        while (front < back) {
            if (!arr.get(front).equals(arr.get(back))) {
                return false;
            }
            front++;
            back--;
        }
        return true;
    }
}
```

## 优化思路

虽然上述方法简单直观，但需要O(n)的额外空间。我们可以通过以下方法优化空间复杂度到O(1)：

1. 找到链表的中点（使用快慢指针）
2. 反转链表的后半部分
3. 比较前半部分和反转后的后半部分是否相同
4. 恢复链表（可选）

优化后的代码如下：

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }
        
        // 找到中点
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // 反转后半部分
        ListNode prev = null;
        while (slow != null) {
            ListNode next = slow.next;
            slow.next = prev;
            prev = slow;
            slow = next;
        }
        
        // 比较前后两部分
        ListNode left = head;
        ListNode right = prev;
        while (right != null) {
            if (left.val != right.val) {
                return false;
            }
            left = left.next;
            right = right.next;
        }
        
        return true;
    }
}
```

## 复杂度分析

### 原始方法
- 时间复杂度：O(n)，需要遍历链表一次，比较数组元素n/2次
- 空间复杂度：O(n)，需要存储所有链表元素

### 优化方法
- 时间复杂度：O(n)，找到中点O(n)，反转O(n/2)，比较O(n/2)
- 空间复杂度：O(1)，只使用了常数级别的额外空间

## 总结

判断链表是否为回文结构有多种解法，各有优缺点：
1. 数组存储法简单直观，但需要额外空间
2. 反转后半部分法空间效率更高，但实现稍复杂
