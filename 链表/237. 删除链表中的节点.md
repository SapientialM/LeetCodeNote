## [237. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

## 题目描述

给定一个单链表中的一个节点（非尾节点），要求删除该节点。注意，我们无法访问链表的头节点 `head`。

题目保证：
1. 链表中的所有值都是唯一的
2. 给定的节点 `node` 不是链表中的最后一个节点

删除节点的定义是：
- 给定节点的值不应该存在于链表中
- 链表中的节点数应该减少1
- 节点前面的所有值顺序相同
- 节点后面的所有值顺序相同

## 解题思路

这道题的关键在于我们无法访问头节点，因此不能通过常规的遍历链表找到前驱节点的方式来删除节点。题目给出的限制条件提示我们需要采用一种"伪装"的方法：

1. 将当前节点的值替换为下一个节点的值
2. 然后删除下一个节点

这样从效果上看，相当于删除了当前节点，因为它的原始值已经被覆盖了。

## 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        ListNode cur = node;
        while(cur.next.next != null){
            cur.val = cur.next.val;
            cur = cur.next;
        }
        cur.val = cur.next.val;
        cur.next = null;
    }
}
```

## 代码解释

这段代码实现了上述思路，但采用了一种更通用的方法：

1. 从给定节点开始，将当前节点的值替换为下一个节点的值
2. 移动到下一个节点，重复这个过程
3. 当到达倒数第二个节点时，复制最后一个节点的值并删除最后一个节点

这种方法确保了：
- 所有后续节点的值都向前移动了一位
- 最终删除了最后一个节点
- 原节点的值被完全覆盖

## 优化思路（直接jump）

实际上，我们不需要逐个移动所有后续节点的值。因为题目保证给定的节点不是尾节点，我们可以直接：

1. 将当前节点的值替换为下一个节点的值
2. 将当前节点的next指针指向下下个节点

这样就只需要两步操作，时间复杂度从O(n)降到了O(1)。

## 优化后的代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

## 复杂度分析

- 原始方法：
  - 时间复杂度：O(n)，需要遍历到链表末尾
  - 空间复杂度：O(1)，只使用了常数空间

- 优化方法：
  - 时间复杂度：O(1)，仅需两次操作
  - 空间复杂度：O(1)，只使用了常数空间
