## [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

## 题目描述

给定两个单链表的头节点 `headA` 和 `headB`，请找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，则返回 `null`。

## 解题思路

这道题的关键在于如何高效地找到两个链表的交点。链表相交的特点是：从交点开始，两个链表后续的节点都是相同的。因此，我们可以采用以下方法：

1. **计算链表长度**：首先遍历两个链表，计算它们的长度。
2. **检查是否相交**：比较两个链表的尾节点是否相同，如果不同则肯定不相交。
3. **对齐起点**：让较长的链表先走长度差值的步数，使两个链表的剩余长度相同。
4. **同步遍历**：同时遍历两个链表，直到找到第一个相同的节点即为交点。

## 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lengthA = 0;
        int lengthB = 0;
        
        // 计算链表A的长度
        while(curA != null){
            lengthA++;
            curA = curA.next;
        }
        
        // 计算链表B的长度
        while(curB != null){
            lengthB++;
            curB = curB.next;
        }
        
        // 检查尾节点是否相同
        if(curA != curB) return null;
        
        // 重置指针
        curA = headA;
        curB = headB;
        
        // 让较长的链表先走差值步数
        int diff = Math.abs(lengthA - lengthB);
        if(lengthA > lengthB){
            while(diff-- > 0) curA = curA.next;
        } else {
            while(diff-- > 0) curB = curB.next;
        }
        
        // 同步遍历寻找交点
        while(curA != curB){
            curA = curA.next;
            curB = curB.next;
        }
        
        return curA;
    }
}
```

## 代码解析

1. **长度计算**：首先遍历两个链表，计算它们的长度。这里使用`while(curA != null)`而不是`while(curA.next != null)`，这样可以正确计算链表的实际长度。
2. **相交检查**：通过比较两个链表的尾节点是否相同来判断是否相交。如果尾节点不同，则肯定不相交。
3. **对齐起点**：计算两个链表的长度差，让较长的链表的指针先移动差值步数，使两个指针之后的剩余长度相同。
4. **同步遍历**：同时移动两个指针，直到找到相同的节点即为交点。

## 优化思路

虽然上述方法已经比较高效，时间复杂度为O(m+n)，空间复杂度为O(1)，但还可以进一步优化：

1. **双指针法**：不需要显式计算链表长度，可以使用两个指针交替遍历两个链表，最终会在交点相遇。
2. **代码简化**：减少一些不必要的变量和步骤。

## 优化后的代码

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA;
        ListNode pB = headB;
        
        while(pA != pB){
            pA = (pA == null) ? headB : pA.next;
            pB = (pB == null) ? headA : pB.next;
        }
        
        return pA;
    }
}
```

## 优化解析

1. **双指针交替遍历**：两个指针分别从两个链表头开始遍历，当到达链表末尾时，切换到另一个链表的头部继续遍历。
2. **相遇原理**：如果两个链表相交，两个指针最终会在交点相遇；如果不相交，两个指针最终都会到达null。
3. **优势**：不需要计算链表长度，代码更简洁，时间复杂度仍为O(m+n)，空间复杂度O(1)。
